Sean Konz and Schuyler Tilney-Volk
EE180, Lab 3: Let's Build a Processor

SUBMITTED EARLY BY MAY 22

In this lab, we implemented the add, addi, addiu, addu, and, andi, beq, bgez, bgtz, blez, bltz, bne, j, jal, jalr, jr, lb, lbu, ll, lui, lw, movn, movz, mul, nor, or, ori, sb, sc, sll, sllv, slt, slti, sltiu, sltu, sra, srav, srl, srlv, sub, subu, sw, xor, xori instructions in MIPS. Some of these were already fully implemented, some partially, and a few not implemented at all. 

In addition, in order to handle hazards, data forwarding, and stalls, we implemented the following: 
    i. Data hazard: For the case of RAW data hazards, we implemented a forwarding logic to detect Mem-ID and EX-ID dependencies and forward the appropriate data to the ID/EX pipeline. In the case this is not enough to prevent the dependency, we also implemented stalling logic, although that was mostly for the load-use hazards. 
    ii. Load Use hazard: For the case of load use hazard, we implemented the stalling logic to detect the MEM-ID dependency and stall the pipeline for 1 idle cycle.
    iii. Control Hazards: For the branch instructions, we have a 1 branch delay slot, which essentially means that the instruction after Branch is always implemented. A 32 bit comparator is added in the Decode stage to predict branch condition early.
    iv. Jump register datapath change for forwarding data: In the case of jr instruction, the forwarded rs_data was transferred to get the jump target beforehand.

    Change to the control logic to obviate hazards:
    i. The data hazards are detected in the decode stage itself. The additional control signals ForwardA, ForwardB are generated in the stage. 
    ii. The Branch condition results are calculated in the decode stage, generating the control signals isBranch for all the different types of branch instructions (beq, bne, bgt, etc), which then passed to Fetch stage to go the the correct next program counter (pc+4, branch target etc)